generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String         @id @default(uuid()) @db.Uuid
  email            String         @unique @db.VarChar(255)
  username         String         @unique @db.VarChar(100)
  password         String         @db.VarChar(255)
  name             String?        @db.VarChar(100)
  imageUrl         String?
  imagePublicId    String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  deletedAt        DateTime?
  houses           HouseToUser[]
  pantryItemsAdded PantryToItem[]
  // Pantry items created by this user
  pantryItems      PantryItem[]
  refreshTokens    RefreshToken[]
  assignedTasks    Task[]         @relation("AssignedTasks")
  assignedTaskLinks TaskToUser[]
  createdTasks     Task[]         @relation("CreatedTasks")
  paidExpenses     Expense[]      @relation("PaidExpenses")
  notifications    NotificationToUser[]
  resetToken       String?        @db.VarChar(500)
  resetTokenExpiry DateTime?
  isEmailVerified  Boolean        @default(false)
  verificationToken String?       @db.VarChar(500)
  googleId         String?        @unique @db.VarChar(255)
  chatMessages      ChatMessage[]
  MessageReadLog    MessageReadLog[]
}

model RefreshToken {
  id        String    @id @default(uuid()) @db.Uuid
  token     String    @unique @db.VarChar(500)
  userId    String    @db.Uuid
  expiresAt DateTime
  isRevoked Boolean   @default(false)
  createdAt DateTime  @default(now())
  revokedAt DateTime?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
}

model GoogleAuthCode {
  code         String   @id @default(uuid()) @db.Uuid
  accessToken  String
  refreshToken String
  expiresAt    DateTime
  createdAt    DateTime @default(now())
}

model House {
  id             String        @id @default(uuid()) @db.Uuid
  name           String
  invitationCode String
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  users          HouseToUser[]
  pantry         Pantry?
  // Pantry items associated with this house (via PantryItem.houseId)
  pantryItems    PantryItem[]
  tasks          Task[]
  expenses       Expense[]
  chatMessages   ChatMessage[]
  notifications  Notification[]
}

model HouseToUser {
  id       String   @id @default(uuid()) @db.Uuid
  userId   String   @db.Uuid
  houseId  String   @db.Uuid
  role     String?
  joinedAt DateTime @default(now())
  house    House    @relation(fields: [houseId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, houseId])
}

model Pantry {
  id        String         @id @default(uuid()) @db.Uuid
  houseId   String         @unique @db.Uuid
  createdAt DateTime       @default(now())
  house     House          @relation(fields: [houseId], references: [id], onDelete: Cascade)
  items     PantryToItem[]

  @@index([houseId])
}

model PantryItem {
  id              String          @id @default(uuid()) @db.Uuid
  name            String
  imageLink       String?
  measurementUnit String?
  category        PantryCategory?
  pantries        PantryToItem[]

  // New fields added by migration: link item to the creating user and house
  createdByUser String @db.Uuid
  houseId       String @db.Uuid

  createdBy User  @relation(fields: [createdByUser], references: [id], onDelete: Cascade)
  house     House @relation(fields: [houseId], references: [id], onDelete: Cascade)

  @@index([createdByUser])
  @@index([houseId])
}

model PantryToItem {
  id             String     @id @default(uuid()) @db.Uuid
  itemId         String     @db.Uuid
  pantryId       String     @db.Uuid
  modifiedByUser String     @db.Uuid
  quantity       Float
  updatedAt      DateTime   @updatedAt
  expiryDate     DateTime?
  lastLowStockNotificationAt DateTime?
  lastExpiryNotificationAt   DateTime?
  item           PantryItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  user           User       @relation(fields: [modifiedByUser], references: [id], onDelete: Cascade)
  pantry         Pantry     @relation(fields: [pantryId], references: [id], onDelete: Cascade)

  @@unique([pantryId, itemId])
  @@index([pantryId])
}

model Task {
  id          String   @id @default(uuid()) @db.Uuid
  title       String   @db.VarChar(255)
  description String?  @db.Text
  status      String   @default("todo") @db.VarChar(20)
  assigneeId  String   @db.Uuid
  assignee    User     @relation("AssignedTasks", fields: [assigneeId], references: [id], onDelete: Cascade)
  createdById String   @db.Uuid
  createdBy   User     @relation("CreatedTasks", fields: [createdById], references: [id], onDelete: Cascade)
  houseId     String   @db.Uuid
  house       House    @relation(fields: [houseId], references: [id], onDelete: Cascade)
  deadline    DateTime
  archived    Boolean  @default(false)
  archivedAt  DateTime?
  size        TaskSize @default(MEDIUM)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  assigneeLinks TaskToUser[]

  isRecurring          Boolean            @default(false)
  recurrencePattern    RecurrencePattern?
  recurrenceInterval   Int?               
  lastRecurrenceDate   DateTime?
  nextRecurrenceDate   DateTime?
  parentRecurringTaskId String?           @db.Uuid
  parentRecurringTask   Task?             @relation("RecurringTaskInstances", fields: [parentRecurringTaskId], references: [id], onDelete: SetNull)
  recurringInstances    Task[]            @relation("RecurringTaskInstances")

  @@index([assigneeId])
  @@index([createdById])
  @@index([houseId])
  @@index([status])
  @@index([isRecurring])
  @@index([nextRecurrenceDate])
  @@index([parentRecurringTaskId])
}

model TaskToUser {
  id         String   @id @default(uuid()) @db.Uuid
  taskId     String   @db.Uuid
  userId     String   @db.Uuid
  assignedAt DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([taskId, userId])
  @@index([taskId])
  @@index([userId])
}

model Expense {
  id          String   @id @default(uuid()) @db.Uuid
  amount      Float
  description String   @db.VarChar(255)
  category    ExpenseCategory
  date        DateTime @default(now())
  paidById    String   @db.Uuid
  houseId     String   @db.Uuid
  splitWith   String[] @db.Uuid
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  paidBy      User          @relation("PaidExpenses", fields: [paidById], references: [id], onDelete: Cascade)
  house       House         @relation(fields: [houseId], references: [id], onDelete: Cascade)
  splits      ExpenseSplit[]

  @@index([houseId])
  @@index([paidById])
  @@index([date])
}

model ExpenseSplit {
  id         String   @id @default(uuid()) @db.Uuid
  expenseId  String   @db.Uuid
  userId     String   @db.Uuid
  percentage Float
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  expense    Expense  @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  
  @@unique([expenseId, userId])
  @@index([expenseId])
  @@index([userId])
}

model Notification {
  id          String   @id @default(uuid()) @db.Uuid
  category    NotificationCategory?
  level       NotificationLevel?
  title       String
  body        String?
  actionUrl   String?
  createdAt   DateTime @default(now())
  houseId     String?  @db.Uuid
  house       House?   @relation(fields: [houseId], references: [id], onDelete: Cascade)

  deliveredTo NotificationToUser[]
}

model NotificationToUser {
  id              String   @id @default(uuid()) @db.Uuid
  userId          String   @db.Uuid
  notificationId  String   @db.Uuid
  isRead          Boolean  @default(false)
  readAt          DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  notification    Notification    @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  deletedAt       DateTime?

  @@index([userId, isRead])
  @@index([notificationId])
  @@index([userId, deletedAt])
}

model ChatMessage {
  id        String        @id @default(uuid()) @db.Uuid
  content   String        @db.VarChar(500)
  userId    String        @db.Uuid
  houseId   String        @db.Uuid
  parentId  String?       @db.Uuid
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  house     House         @relation(fields: [houseId], references: [id], onDelete: Cascade)
  parent    ChatMessage?  @relation("MessageReplies", fields: [parentId], references: [id], onDelete: SetNull)
  replies   ChatMessage[] @relation("MessageReplies")

  readLogs MessageReadLog[]

  @@index([userId])
  @@index([houseId])
  @@index([userId, houseId])
  @@index([parentId])
}

model MessageReadLog {
  id        String   @id @default(uuid()) @db.Uuid
  messageId String   @db.Uuid
  userId    String   @db.Uuid
  readAt    DateTime @default(now())

  message ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
}

enum PantryCategory {
  OTHER
  GRAINS
  DAIRY
  VEGETABLES
  FRUITS
  MEAT
  FROZEN
  CONDIMENTS
  BEVERAGES
}

enum ExpenseCategory {
  GROCERIES
  UTILITIES
  HOUSEHOLD
  FOOD
  ENTERTAINMENT
  TRANSPORTATION
  SETTLEMENT
  OTHER
}

enum NotificationCategory {
  HOUSE
  PANTRY 
  EXPENSES 
  SCRUM
  CHAT
  OTHER
}

enum NotificationLevel {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TaskSize {
  SMALL
  MEDIUM
  LARGE
  XL
}

enum RecurrencePattern {
  DAILY
  WEEKLY
  MONTHLY
}
